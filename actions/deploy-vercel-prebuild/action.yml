name: 'Deploy Vercel Prebuild'
description: 'Download prebuild artifact, set environment variables, run migrations, and deploy to Vercel with GitHub deployment status'

inputs:
  vercel-token:
    description: 'Vercel API token'
    required: true
  vercel-team-slug:
    description: 'Vercel team slug for scoping API calls'
    required: true
  environment:
    description: 'Vercel environment (preview, staging, or production)'
    required: true
  artifact-name:
    description: 'Name of the GitHub artifact containing the prebuild'
    required: false
    default: 'vercel-build-output'
  description:
    description: 'Description for the GitHub deployment'
    required: false
    default: 'Automated deployment'

outputs:
  deployment-url:
    description: 'URL of the deployed Vercel application'
    value: ${{ steps.deploy.outputs.deployment-url }}
  deployment-id:
    description: 'GitHub deployment ID'
    value: ${{ steps.create-deployment.outputs.deployment-id }}

runs:
  using: composite
  steps:
    - name: Validate environment input
      shell: bash
      run: |
        if [[ "${{ inputs.environment }}" != "preview" && "${{ inputs.environment }}" != "staging" && "${{ inputs.environment }}" != "production" ]]; then
          echo "Error: environment must be either 'preview', 'staging', or 'production', got '${{ inputs.environment }}'"
          exit 1
        fi

    # Create GitHub deployment
    - name: Create deployment
      id: create-deployment
      uses: ./.github/actions/manage-deployment-status
      with:
        environment: ${{ inputs.environment }}
        description: ${{ inputs.description }}
        status: in_progress

    - name: Download Vercel build output
      uses: actions/download-artifact@v5
      with:
        name: ${{ inputs.artifact-name }}
    - name: Unpack next.js build
      shell: bash
      run: |
        rm -rf .next
        tar -xzvf .out/next-build.tgz

    - name: Set environment variables
      uses: ./.github/actions/pull-vercel-env
      with:
        environment: ${{ inputs.environment == 'staging' && 'production' || inputs.environment }}
        vercel-token: ${{ inputs.vercel-token }}

    - name: Run database migrations
      shell: bash
      run: |
        echo "Running database migrations for ${{ inputs.environment }} environment..."
        pnpm run db:migrate

    - name: Deploy to Vercel
      id: deploy
      shell: bash
      run: |
        set -euo pipefail
        echo "::add-mask::${{ inputs.vercel-token }}"

        echo "Deploying to Vercel (${{ inputs.environment }} environment)..."

        # Get current commit SHA for meta tagging
        COMMIT_SHA="${{ github.sha }}"
        echo "Tagging deployment with commit SHA: $COMMIT_SHA"

        if [[ "${{ inputs.environment }}" == "production" || "${{ inputs.environment }}" == "staging" ]]; then
          # Deploy with --prod flag for production builds (creates staged production build)
          echo "Running: npx vercel deploy --archive=tgz --prebuilt --prod --scope ${{ inputs.vercel-team-slug }}"
          DEPLOYMENT_URL=$(npx vercel deploy --archive=tgz --prebuilt --prod --yes --token "${{ inputs.vercel-token }}" --meta commitSha="$COMMIT_SHA" --scope "${{ inputs.vercel-team-slug }}")
          echo "${{ inputs.environment }} deployment URL: $DEPLOYMENT_URL"
        else
          # Deploy to preview environment
          echo "Running: npx vercel deploy --archive=tgz --prebuilt --scope ${{ inputs.vercel-team-slug }}"
          DEPLOYMENT_URL=$(npx vercel deploy --archive=tgz --prebuilt --yes --token "${{ inputs.vercel-token }}" --meta commitSha="$COMMIT_SHA" --scope "${{ inputs.vercel-team-slug }}")
          echo "Preview deployment URL: $DEPLOYMENT_URL"
        fi

        # Verify deployment URL was captured
        if [[ -z "$DEPLOYMENT_URL" ]]; then
          echo "Error: Failed to capture deployment URL"
          exit 1
        fi

        # Set output for other steps/jobs to use
        echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
        echo "Successfully deployed to: $DEPLOYMENT_URL"

    # Update deployment status to success
    - name: Update deployment status to success
      if: success()
      uses: ./.github/actions/manage-deployment-status
      with:
        deployment-id: ${{ steps.create-deployment.outputs.deployment-id }}
        environment: ${{ inputs.environment }}
        deployment-url: ${{ steps.deploy.outputs.deployment-url }}
        status: success

    # Update deployment status to failure if deployment fails
    - name: Update deployment status to failure
      if: failure()
      uses: ./.github/actions/manage-deployment-status
      with:
        deployment-id: ${{ steps.create-deployment.outputs.deployment-id }}
        environment: ${{ inputs.environment }}
        status: failure

    # Add PR comment for preview deployments
    - name: Comment on PR
      if: success() && inputs.environment == 'preview' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const comment = `ðŸš€ **Preview Deployment Ready**

          Your changes have been deployed to a preview environment:

          **ðŸ”— [View Preview](${{ steps.deploy.outputs.deployment-url }})**

          This deployment will automatically update when you push new commits to this PR.

          ---
          <sub>Deployed from commit ${context.sha.substring(0, 7)}</sub>`;

          // Check if we already have a comment from this bot
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const botComment = comments.data.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('Preview Deployment Ready')
          );

          if (botComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }
